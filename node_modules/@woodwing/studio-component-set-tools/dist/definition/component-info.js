"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processInfo = exports.generateComponentSetInfo = void 0;
const components_definition_1 = require("../models/components-definition");
const process_templates_1 = require("./process-templates");
const parse5 = require("parse5");
const directivePrefix = 'doc-';
/**
 * Creates partial info definitions of the component set.
 *
 * This information is provided with custom channel publish messages. Integrators can use
 * the info to interpret the given digital article without additional API requests.
 */
function generateComponentSetInfo(componentsDefinition, renditionResolver) {
    return __awaiter(this, void 0, void 0, function* () {
        yield process_templates_1.processTemplates(renditionResolver, componentsDefinition);
        return processInfo(componentsDefinition);
    });
}
exports.generateComponentSetInfo = generateComponentSetInfo;
/**
 * @see generateComponentSetInfo
 *
 * This implementation can be used when the components definition already contains the rendition information.
 */
function processInfo(componentsDefinition) {
    return {
        components: componentsDefinition.components.reduce((result, component) => {
            result[component.name] = {
                fields: parseFields(component.renditions[components_definition_1.ComponentRendition.HTML]),
            };
            result[component.name].fields.forEach((f) => addRestrictChildrenInfo(componentsDefinition, component, f));
            return result;
        }, {}),
    };
}
exports.processInfo = processInfo;
function parseFields(template) {
    const componentFields = [];
    const templateFragment = parse5.parseFragment(template);
    parseNodes(componentFields, templateFragment.childNodes);
    return componentFields;
}
function parseNodes(componentFields, nodes) {
    if (!nodes) {
        return;
    }
    nodes.forEach((node) => parseNode(componentFields, node));
}
function parseNode(componentFields, node) {
    // parse attributes before child nodes, as the fields should be ordered
    parseAttributes(componentFields, node.attrs);
    parseNodes(componentFields, node.childNodes);
}
function parseAttributes(componentFields, attrs) {
    if (!attrs) {
        return;
    }
    attrs.forEach((attr) => {
        if (!attr.name.startsWith(directivePrefix)) {
            return;
        }
        componentFields.push({
            contentKey: attr.value,
            type: attr.name.replace(directivePrefix, ''),
        });
    });
}
function addRestrictChildrenInfo(componentDefinition, component, field) {
    if (field.type !== 'container') {
        return;
    }
    let allowedComponentsNames = componentDefinition.components
        .filter((def) => !(def.allowNesting === 'no' || def.name === component.name))
        .map((def) => def.name);
    if (component.restrictChildren) {
        const restrictChildren = Object.keys(component.restrictChildren);
        allowedComponentsNames = restrictChildren.filter((child) => allowedComponentsNames.includes(child));
    }
    field.restrictChildren = allowedComponentsNames;
}
//# sourceMappingURL=component-info.js.map