"use strict";
/**
 * Utils which parse components definition
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDefinition = void 0;
const htmlparser = require("htmlparser2");
const models_1 = require("../models");
/**
 * Parses the components definition into the object which contains all needed data to make needed validations
 * It already validates:
 * - the existence of component properties
 * - the existence of directives that properties point to
 * - that directive keys are unique within a component html template
 * - that group names are unique
 * - that components have at least an HTML rendition
 */
function parseDefinition(componentsDefinition) {
    return __awaiter(this, void 0, void 0, function* () {
        const componentSet = {
            name: componentsDefinition.name,
            description: componentsDefinition.description,
            version: componentsDefinition.version,
            components: {},
            groups: componentsDefinition.groups,
            defaultComponentOnEnter: componentsDefinition.defaultComponentOnEnter,
            defaultComponentContent: {},
            conversionRules: componentsDefinition.conversionRules,
            shortcuts: componentsDefinition.shortcuts,
            scripts: componentsDefinition.scripts || [],
            customStyles: componentsDefinition.customStyles || [],
        };
        for (const compDef of componentsDefinition.components) {
            componentSet.components[compDef.name] = parseComponent(compDef, componentsDefinition.componentProperties, models_1.ComponentRendition.HTML);
        }
        buildComponentSetDefaultContent(componentSet);
        return componentSet;
    });
}
exports.parseDefinition = parseDefinition;
/**
 * Returns information about directives
 *
 * @param content HTML content of the component
 * @returns ParsedComponentsDefinition['components']['name']['directives']
 */
function parseDirectives(content) {
    const result = {};
    const parser = new htmlparser.Parser({
        onopentag: (name, attributes) => {
            Object.keys(attributes).forEach((key) => {
                const keyLowerCased = key.toLowerCase();
                const prefix = 'doc-';
                if (keyLowerCased.indexOf(prefix) === 0) {
                    const directiveType = getDirectiveType(keyLowerCased.substr(prefix.length));
                    const directiveKey = attributes[key];
                    if (directiveKey in result) {
                        throw new Error(`Directive's attributes must be unique. Attribute value is "${directiveKey}"`);
                    }
                    result[directiveKey] = {
                        type: directiveType,
                        tag: name.toLowerCase(),
                    };
                }
            });
        },
    });
    parser.write(content);
    parser.end();
    return result;
}
/**
 * Find directive type using passed string
 */
function getDirectiveType(directiveName) {
    return (Object.values(models_1.DirectiveType).find((directiveType) => directiveType === directiveName) || models_1.DirectiveType.unknown);
}
/**
 * Checks if component has needed rendition
 */
function hasRendition(component, rendition) {
    return Boolean(component.renditions && rendition in component.renditions);
}
function parseComponent(component, componentProperties, rendition) {
    if (!hasRendition(component, rendition)) {
        throw new Error(`Component "${component.name}" doesn't have "${rendition}" rendition`);
    }
    const directives = parseDirectives((component.renditions && component.renditions[rendition]) || '');
    return Object.assign(Object.assign({}, component), { directives: directives, properties: (component.properties || []).map((componentProperty) => {
            const property = parseProperty(componentProperty, componentProperties);
            validateDirective(property.directiveKey, directives, component.name, property.name);
            parseConditionalChildProperties(property, componentProperties, directives, component.name);
            return property;
        }), noCreatePermission: false });
}
function parseProperty(componentProperty, componentProperties) {
    // Creates a shallow clone of the property object, so properties can be re-assigned.
    return isPropertyObject(componentProperty)
        ? parseComponentPropertyObject(componentProperty, componentProperties)
        : findComponentPropertyTemplate(componentProperty, componentProperties);
}
function parseComponentPropertyObject(componentProperty, componentProperties) {
    // No name means the property is defined anonymously.
    // Otherwise the property is merged with componentProperties entry. This entry must exist
    return componentProperty.name
        ? Object.assign(Object.assign({}, findComponentPropertyTemplate(componentProperty.name, componentProperties)), componentProperty) : componentProperty;
}
function findComponentPropertyTemplate(propertyName, componentProperties) {
    const propertyTemplate = componentProperties.find((item) => item.name === propertyName);
    if (!propertyTemplate) {
        throw new Error(`Property "${propertyName}" is not found in definition componentProperties`);
    }
    return Object.assign({}, propertyTemplate);
}
function isPropertyObject(property) {
    return property instanceof Object;
}
function parseConditionalChildProperties(property, componentProperties, directives, componentName) {
    if (!property.childProperties || property.childProperties.length === 0)
        return;
    property.childProperties = property.childProperties.map((conditionalChildProperties) => (Object.assign(Object.assign({}, conditionalChildProperties), { properties: conditionalChildProperties.properties.map((componentProperty) => {
            const childProperty = parseProperty(componentProperty, componentProperties);
            validateDirective(childProperty.directiveKey, directives, componentName, childProperty.name);
            return childProperty;
        }) })));
}
function validateDirective(directiveKey, directives, componentName, propertyName) {
    if (directiveKey && !(directiveKey in directives)) {
        throw new Error(`Directive with key "${directiveKey}" is not found in component "${componentName}". Property name is "${propertyName || '<anonymous property>'}".`);
    }
}
/**
 * Builds default content for when a component is created.
 * This goes through the component properties and looks for default values.
 * These defaultValues are stored in a model object, that's used as initial
 * data for the component when inserted.
 *
 * Default values are only supported for the basic data types (styles, inlineStyles and data).
 * Directive default values are excluded for now, as in general they are not needed.
 * In case we do want to expand support, consider trying to merge the logic of creating default
 * content with the properties classes, as both deal with the article format.
 * Alternatively the default values could be set after component creation, but this would
 * generate more data operations and trigger more view updates (needs to be tested through).
 */
function buildComponentSetDefaultContent(componentSet) {
    for (const component of Object.values(componentSet.components)) {
        buildComponentDefaultContent(componentSet.defaultComponentContent, component);
    }
}
/**
 * Build default component model for given component and add to defaultComponentContent input.
 */
function buildComponentDefaultContent(defaultComponentContent, component) {
    for (const property of component.properties) {
        buildComponentPropertyDefaultContent(defaultComponentContent, component.name, property);
        buildConditionalChildPropertiesDefaultContent(defaultComponentContent, component.name, property);
    }
}
function buildConditionalChildPropertiesDefaultContent(defaultComponentContent, componentName, property) {
    if (!property.childProperties || property.childProperties.length === 0)
        return;
    const childProperties = property.childProperties.find((candidate) => candidate.matchExpression === property.defaultValue);
    if (!childProperties)
        return;
    for (const childProperty of childProperties.properties) {
        buildComponentPropertyDefaultContent(defaultComponentContent, componentName, childProperty);
    }
}
/**
 * Build default component model property data and add to defaultComponentContent.
 */
function buildComponentPropertyDefaultContent(defaultComponentContent, componentName, property) {
    // No default value
    if (!property.defaultValue) {
        return;
    }
    switch (property.dataType) {
        case 'styles':
            addDefaultPropertyContent(defaultComponentContent, 'styles', componentName, property.name, property.defaultValue);
            break;
        case 'inlineStyles':
            addDefaultPropertyContent(defaultComponentContent, 'inlineStyles', componentName, property.name, property.defaultValue);
            break;
        case 'data':
            addDefaultPropertyContent(defaultComponentContent, 'data', componentName, property.name, property.defaultValue);
            break;
        default:
        // Note: validator doesn't allow such a value in component definitions
    }
}
/**
 * Adds default value to default component model.
 * Creates necessary structure when needed.
 */
function addDefaultPropertyContent(defaultComponentContent, dataTypeKey, componentName, propertyName, value) {
    if (!defaultComponentContent[componentName]) {
        defaultComponentContent[componentName] = {};
    }
    if (!defaultComponentContent[componentName][dataTypeKey]) {
        defaultComponentContent[componentName][dataTypeKey] = {};
    }
    // TypeScript incorrectly does not infer the structure is initialised above.
    // Seems related to the string union type for dataTypeKey
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    defaultComponentContent[componentName][dataTypeKey][propertyName] = value;
}
//# sourceMappingURL=parser-utils.js.map