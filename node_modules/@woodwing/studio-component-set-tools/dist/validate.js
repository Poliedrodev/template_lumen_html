"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidators = exports.validatePackageSize = exports.validate = exports.validateFolder = exports.getSize = exports.readFile = void 0;
const fs = require("fs");
const path = require("path");
const semver = require("semver");
const ajv_1 = require("ajv");
const ajv_formats_1 = require("ajv-formats");
const chalk = require("chalk");
const jsonMap = require("json-source-map");
const components_schema_v1_0_x_1 = require("./components-schema-v1_0_x");
const components_schema_v1_1_x_1 = require("./components-schema-v1_1_x");
const components_schema_v1_2_x_1 = require("./components-schema-v1_2_x");
const components_schema_v1_3_x_1 = require("./components-schema-v1_3_x");
const components_schema_v1_4_x_1 = require("./components-schema-v1_4_x");
const components_schema_v1_5_x_1 = require("./components-schema-v1_5_x");
const components_schema_v1_6_x_1 = require("./components-schema-v1_6_x");
const components_schema_v1_7_x_1 = require("./components-schema-v1_7_x");
const components_schema_v1_8_x_1 = require("./components-schema-v1_8_x");
const components_schema_v1_9_x_1 = require("./components-schema-v1_9_x");
const parser_1 = require("./parser");
const validators_1 = require("./validators");
const files_1 = require("./util/files");
const renditions_1 = require("./renditions");
const freeze_1 = require("./util/freeze");
const ajvInstance = new ajv_1.default({ allErrors: true, verbose: true, allowUnionTypes: true });
ajv_formats_1.default(ajvInstance);
const componentsDefinitionPath = 'components-definition.json';
const readFile = (pathToFile, options) => new Promise((resolve, reject) => {
    return fs.readFile(pathToFile, options, (err, data) => {
        if (err) {
            reject(err);
        }
        else {
            resolve(data);
        }
    });
});
exports.readFile = readFile;
const getSize = (pathToFile) => {
    return new Promise((resolve, reject) => {
        return fs.stat(pathToFile, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data.size);
            }
        });
    });
};
exports.getSize = getSize;
/**
 * Validates a components package based on folder path.
 *
 * @param folderPath Path to folder containing the components.
 */
function validateFolder(folderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield files_1.listFilesRelativeToFolder(folderPath);
        const getFileContent = (filePath, options) => __awaiter(this, void 0, void 0, function* () { return exports.readFile(path.resolve(folderPath, filePath), options); });
        const getFileSize = (filePath) => __awaiter(this, void 0, void 0, function* () { return exports.getSize(path.resolve(folderPath, filePath)); });
        return validate(files, getFileContent, getFileSize, (errorMessage) => {
            console.log(chalk.redBright(errorMessage));
        });
    });
}
exports.validateFolder = validateFolder;
/**
 * Validates a components package given an array of paths
 * and a function to get the file content.
 *
 * @param filePaths normalized paths to files, relative to root folder of components package
 * @param getFileContent an async function that resolves with the file content
 * @param getFileSize an async function that resolves with the file size
 * @param errorReporter called when there is a validation error
 */
function validate(filePaths, getFileContent, getFileSize, errorReporter) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!filePaths.has(componentsDefinitionPath)) {
            errorReporter(`Components definition file "${componentsDefinitionPath}" is missing`);
            return false;
        }
        const componentsDefinitionContent = (yield getFileContent(componentsDefinitionPath, {
            encoding: 'utf8',
        }));
        const { data: componentsDefinition, pointers: componentsDefinitionSourcePointers } = yield getComponentsDefinition(componentsDefinitionContent, errorReporter);
        if (!componentsDefinition) {
            return false;
        }
        freeze_1.deepFreeze(componentsDefinition);
        const validateSchema = getValidationSchema(componentsDefinition.version);
        if (!validateSchema) {
            errorReporter(`Could not find validation schema for component model version "${componentsDefinition.version}"`);
            return false;
        }
        if (!validateSchema(componentsDefinition)) {
            if (validateSchema.errors) {
                const jsonLines = componentsDefinitionContent.split('\n');
                validateSchema.errors.forEach((error) => {
                    if (!componentsDefinitionSourcePointers) {
                        return;
                    }
                    const errorPointer = componentsDefinitionSourcePointers[error.dataPath];
                    let errorMessage = `${error.dataPath} ${error.message}\n${JSON.stringify(error.params, undefined, 4)}`;
                    errorMessage += `\n${componentsDefinitionPath} - line ${errorPointer.value.line}, column ${errorPointer.value.column}:`;
                    errorMessage += `\n> ${jsonLines
                        .slice(errorPointer.value.line, Math.max(errorPointer.valueEnd.line, errorPointer.value.line + 1))
                        .join('\n> ')}\n`;
                    errorReporter(errorMessage);
                });
            }
            return false;
        }
        // parse everything for deeper testing
        let componentSet = null;
        try {
            componentSet = yield parser_1.parseDefinition(yield renditions_1.loadHtmlRenditions(componentsDefinition, getFileContent));
        }
        catch (e) {
            errorReporter((_a = e.message) !== null && _a !== void 0 ? _a : e);
        }
        // can't run validators if the parser has failed
        if (!componentSet) {
            return false;
        }
        // Wrap the error reporter to detect if it's called
        let valid = true;
        const validateError = (errorMessage) => {
            valid = false;
            errorReporter(errorMessage);
            return valid;
        };
        const validators = getValidators(componentsDefinition.version, validateError, componentSet, filePaths, getFileContent, getFileSize);
        if (!validators) {
            errorReporter(`Could not find validators for component model version "${componentsDefinition.version}"`);
            return false;
        }
        for (const validator of validators) {
            yield validator.validate();
        }
        return valid;
    });
}
exports.validate = validate;
/**
 * Validates the total file size of the component set package.
 *
 * @param size component set package size in bytes
 * @param errorReporter called when there is a validation error
 */
function validatePackageSize(size, errorReporter) {
    const error = validators_1.validateTotalSize(size);
    if (error) {
        errorReporter(error);
        return false;
    }
    return true;
}
exports.validatePackageSize = validatePackageSize;
function getComponentsDefinition(componentsDefinitionContent, errorReporter) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return jsonMap.parse(componentsDefinitionContent);
        }
        catch (e) {
            errorReporter(chalk.redBright(`Components definition file "${componentsDefinitionPath}" is not valid json: \n${e}`));
        }
        return { data: null, pointers: null };
    });
}
const semVerOptions = { includePrerelease: true };
/**
 * Returns the validation function for given version.
 *
 * @param version
 * @returns schema validation function if found, otherwise null.
 */
function getValidationSchema(version) {
    const schemaSource = getValidationSchemaSource(version);
    return schemaSource !== null ? ajvInstance.compile(schemaSource) : null;
}
/**
 * Returns the validation schema source for given version.
 *
 * @param version
 * @returns schema validation schema source if found, otherwise null.
 */
function getValidationSchemaSource(version) {
    // Only one version supported
    // When introducing a patch version, make sure to update the supported range, e.g. '1.0.0 - 1.0.1'
    if (semver.satisfies(version, '1.0.0', semVerOptions)) {
        return components_schema_v1_0_x_1.componentsDefinitionSchema_v1_0_x;
    }
    else if (semver.satisfies(version, '1.1.x', semVerOptions)) {
        return components_schema_v1_1_x_1.componentsDefinitionSchema_v1_1_x;
    }
    else if (semver.satisfies(version, '1.2.x', semVerOptions)) {
        return components_schema_v1_2_x_1.componentsDefinitionSchema_v1_2_x;
    }
    else if (semver.satisfies(version, '1.3.x', semVerOptions)) {
        return components_schema_v1_3_x_1.componentsDefinitionSchema_v1_3_x;
    }
    else if (semver.satisfies(version, '1.4.x', semVerOptions)) {
        return components_schema_v1_4_x_1.componentsDefinitionSchema_v1_4_x;
    }
    else if (semver.satisfies(version, '1.5.x', semVerOptions)) {
        return components_schema_v1_5_x_1.componentsDefinitionSchema_v1_5_x;
    }
    else if (semver.satisfies(version, '1.6.x', semVerOptions)) {
        return components_schema_v1_6_x_1.componentsDefinitionSchema_v1_6_x;
    }
    else if (semver.satisfies(version, '1.7.x', semVerOptions)) {
        return components_schema_v1_7_x_1.componentsDefinitionSchema_v1_7_x;
    }
    else if (semver.satisfies(version, '1.8.x', semVerOptions)) {
        return components_schema_v1_8_x_1.componentsDefinitionSchema_v1_8_x;
    }
    else if (semver.satisfies(version, '1.9.0-next', semVerOptions)) {
        return components_schema_v1_9_x_1.componentsDefinitionSchema_v1_9_x;
    }
    return null;
}
/**
 * Returns set of validators according to component definition version
 */
function getValidators(version, error, componentSet, filePaths, getFileContent, getFileSize) {
    let validators = [];
    if (semver.satisfies(version, '>=1.0.0', semVerOptions)) {
        validators = validators.concat(new validators_1.ComponentsValidator(error, componentSet, filePaths), new validators_1.DirectiveOptionsValidator(error, componentSet), new validators_1.ConversionRulesValidator(error, componentSet), new validators_1.DefaultComponentOnEnterValidator(error, componentSet), new validators_1.DefaultValuesValidator(error, componentSet), new validators_1.DirectivePropertiesValidator(error, componentSet), new validators_1.DocContainerValidator(error, componentSet), new validators_1.DocMediaValidator(error, componentSet), new validators_1.DocSlideshowValidator(error, componentSet), new validators_1.DropCapitalValidator(error, componentSet), new validators_1.FittingValidator(error, componentSet), new validators_1.FocuspointValidator(error, componentSet), new validators_1.GroupsValidator(error, componentSet), new validators_1.IconsValidator(error, componentSet, getFileContent), new validators_1.ImageEditorValidator(error, componentSet), new validators_1.InteractiveValidator(error, componentSet), new validators_1.PropertiesValidator(error, componentSet, filePaths), new validators_1.RestrictChildrenValidator(error, componentSet), new validators_1.ScriptsValidator(error, componentSet, filePaths), new validators_1.SlidesValidator(error, componentSet), new validators_1.UnitTypeValidator(error, componentSet), new validators_1.LocalizationValidator(error, componentSet, filePaths, getFileContent), new validators_1.PackageValidator(error, componentSet, filePaths, getFileSize), new validators_1.CustomStylesValidator(error, componentSet, filePaths));
    }
    if (semver.satisfies(version, '>=1.1.0', semVerOptions)) {
        validators = validators.concat(new validators_1.AutofillValidator(error, componentSet), new validators_1.DefaultComponentOnEnterOverrideValidator(error, componentSet), new validators_1.DocContainerGroupsValidator(error, componentSet));
    }
    if (semver.satisfies(version, '>=1.3.0', semVerOptions)) {
        validators = validators.concat(new validators_1.ConversionShortcutsValidator(error, componentSet));
    }
    if (semver.satisfies(version, '>=1.0.0 <1.4.0', semVerOptions)) {
        validators = validators.concat(new validators_1.DisableFullscreenCheckboxValidator(error, componentSet));
    }
    if (semver.satisfies(version, '>=1.6.0', semVerOptions)) {
        validators = validators.concat(new validators_1.StripStylingOnPasteValidator(error, componentSet));
    }
    return validators.length > 0 ? validators : null;
}
exports.getValidators = getValidators;
//# sourceMappingURL=validate.js.map