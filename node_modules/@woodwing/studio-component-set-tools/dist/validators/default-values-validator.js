"use strict";
/**
 * Validates if default values for properties are valid.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultValuesValidator = void 0;
const validator_1 = require("./validator");
const component_property_controls_1 = require("../models/component-property-controls");
const validDataTypes = new Set(['styles', 'inlineStyles', 'data']);
class DefaultValuesValidator extends validator_1.Validator {
    constructor() {
        super(...arguments);
        this.controlTypeToValidateMethod = new Map([
            ['text', this.validateTextControlValue],
            ['select', this.validateSelectOrRadioControlValue],
            ['radio', this.validateSelectOrRadioControlValue],
            ['checkbox', this.validateCheckboxControlValue],
            ['drop-capital', this.validateDropCapitalControlValue],
            ['fitting', this.validateFittingControlValue],
            ['slider', this.validateSliderControlType],
        ]);
        this.controlTypesRequiringDefaultValue = new Set(['slider']);
    }
    validate() {
        return __awaiter(this, void 0, void 0, function* () {
            Object.values(this.componentSet.components).forEach((component) => this.validateComponent(component));
        });
    }
    /**
     * Iterate through all properties of given component.
     */
    validateComponent(component) {
        component.properties.forEach((property) => this.validateProperty(property));
    }
    /**
     * Validate property has a valid dataType for the given default value if any.
     */
    validateProperty(property) {
        if (property.defaultValue === undefined) {
            this.validateDefaultValueRequiredFor(property);
            return;
        }
        if (!validDataTypes.has(property.dataType)) {
            this.error(`Property ${property.name} has a default value for an unsupported data type ${property.dataType}`);
            return;
        }
        const validateControl = this.controlTypeToValidateMethod.get(property.control.type);
        if (!validateControl) {
            this.error(`Property ${property.name} has a default value used with an unsupported control type ${property.control.type}`);
            return;
        }
        return validateControl.bind(this)(property);
    }
    validateDefaultValueRequiredFor(property) {
        if (this.controlTypesRequiringDefaultValue.has(property.control.type)) {
            this.error(`Property ${property.name} defaultValue is required for control type "${property.control.type}"`);
            return;
        }
    }
    validateValue(property, acceptedTypes) {
        if (!Array.isArray(acceptedTypes)) {
            acceptedTypes = [acceptedTypes];
        }
        if (!acceptedTypes.some((acceptedType) => typeof property.defaultValue === acceptedType)) {
            this.error(`Property ${property.name} defaultValue must be one of (${acceptedTypes.join(' | ')})`);
            return false;
        }
        return true;
    }
    /**
     * Validate defaultValue against text control type.
     */
    validateTextControlValue(property) {
        // Allow any default string value for text
        this.validateValue(property, 'string');
    }
    /**
     * Validate defaultValue against select or radio control type.
     */
    validateSelectOrRadioControlValue(property) {
        if (!this.validateValue(property, 'string')) {
            return;
        }
        if (!property.control.options.find((option) => option.value === property.defaultValue)) {
            this.error(`Property ${property.name} defaultValue has no matching entry in ${property.control.type} options`);
        }
    }
    /**
     * Validate defaultValue for checkbox control type.
     */
    validateCheckboxControlValue(property) {
        if (!this.validateValue(property, property.dataType === 'data' ? ['string', 'boolean'] : 'string')) {
            return;
        }
        if (property.defaultValue !== property.control.value) {
            this.error(`Property ${property.name} defaultValue does not match ${property.control.type} value`);
        }
    }
    /**
     * Validates defaultValue for drop-capital control type.
     */
    validateDropCapitalControlValue(property) {
        if (!this.validateValue(property, 'object')) {
            return;
        }
        const expectedKeys = ['numberOfCharacters', 'numberOfLines', 'padding'];
        const presentKeys = Object.keys(property.defaultValue);
        if (expectedKeys.length !== presentKeys.length || !expectedKeys.every((key) => presentKeys.indexOf(key) >= 0)) {
            this.error(`Property ${property.name} defaultValue must be an object with keys "${expectedKeys.join(', ')}"`);
        }
        presentKeys.forEach((key) => {
            if (typeof property.defaultValue[key] !== 'number') {
                this.error(`Property ${property.name} defaultValue must be an object of number type values`);
            }
        });
    }
    /**
     * Validates defaultValue for fitting control type.
     */
    validateFittingControlValue(property) {
        if (!this.validateValue(property, 'string')) {
            return;
        }
        const values = Object.values(component_property_controls_1.COMPONENT_PROPERTY_CONTROL_FITTING_VALUES);
        if (!values.find((value) => value === property.defaultValue)) {
            this.error(`Property ${property.name} defaultValue has to be one of '${values.join("', '")}'. To use 'fit content to frame' the property needs to be removed from the definition.`);
        }
    }
    /**
     * Validates defaultValue for slider control type.
     */
    validateSliderControlType(property) {
        if (!this.validateValue(property, 'number')) {
            return;
        }
        const sliderControl = property.control;
        const defaultValue = property.defaultValue;
        if (defaultValue < sliderControl.minValue || defaultValue > sliderControl.maxValue) {
            this.error(`Property ${property.name} defaultValue must be between the minimum and maximum values`);
        }
    }
}
exports.DefaultValuesValidator = DefaultValuesValidator;
//# sourceMappingURL=default-values-validator.js.map