"use strict";
/**
 * Validates properties
 * - if names are unique
 * - if icons are present
 * - if reserved words are not used as names
 * - if doc-media properties have a media-properties control type
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertiesValidator = void 0;
const path = require("path");
const validator_1 = require("./validator");
const semver = require("semver");
const RESERVED = [/^parallax$/];
const TYPES_ALLOWING_CHILD_PROPERTIES = [
    'select',
    'checkbox',
    'radio',
    'text',
    'textarea',
    'url',
    'time',
    'colorPicker',
    'slider',
];
class PropertiesValidator extends validator_1.Validator {
    constructor(error, definition, filePaths) {
        super(error, definition);
        this.filePaths = filePaths;
    }
    validate() {
        return __awaiter(this, void 0, void 0, function* () {
            Object.values(this.componentSet.components).forEach((component) => this.validateComponent(component));
        });
    }
    validateComponent(component) {
        const componentPropertyNames = new Set();
        component.properties.forEach((property) => this.validateProperty(property, componentPropertyNames, component));
        component.properties.forEach((property) => this.validateChildProperties(property, componentPropertyNames, component));
    }
    validateProperty(property, componentPropertyNames, component) {
        this.validateReservedPropertyName(property);
        this.validatePropertyName(property, componentPropertyNames, component);
        this.validateRadioPropertyIcons(property);
        this.validateCheckBoxValue(property);
    }
    validatePropertyName(property, componentPropertyNames, component) {
        if (!property.name) {
            this.validateNamelessProperty(property, component);
            return;
        }
        if (componentPropertyNames.has(property.name)) {
            this.error(`Component property "${property.name}" used in component "${component.name}" is not unique`);
        }
        componentPropertyNames.add(property.name);
    }
    validateReservedPropertyName(property) {
        if (semver.satisfies(this.componentSet.version, '>=1.4.x')) {
            return;
        }
        if (RESERVED.some((regexp) => regexp.test(property.name))) {
            this.error(`Component property name "${property.name}" is a reserved word`);
        }
    }
    validateNamelessProperty(property, component) {
        if (property.control.type !== 'header') {
            this.error(`Property in component "${component.name}" must have a name when using control type "${property.control.type}"`);
        }
        if (property.dataType) {
            this.error(`Nameless property with control type "${property.control.type}" and label "${property.label}" in component "${component.name}" cannot have a dataType`);
        }
    }
    validateRadioPropertyIcons(property) {
        if (property.control.type !== 'radio') {
            return;
        }
        for (const controlOption of property.control.options) {
            if (!this.filePaths.has(path.normalize(controlOption.icon))) {
                this.error(`Component properties "${property.name}" icon missing "${controlOption.icon}"`);
            }
        }
    }
    validateCheckBoxValue(property) {
        if (property.control.type !== 'checkbox') {
            return;
        }
        if (typeof property.control.value === 'boolean' && property.dataType !== 'data') {
            this.error(`Checkbox property "${property.name}" cannot have a boolean value for dataType "${property.dataType}", boolean values are only allowed for dataType "data"`);
        }
    }
    validateChildProperties(property, componentPropertyNames, component) {
        if (!property.childProperties)
            return;
        if (!TYPES_ALLOWING_CHILD_PROPERTIES.includes(property.control.type)) {
            this.error(`Property in component "${component.name}" with control type "${property.control.type}" cannot contain child properties`);
        }
        property.childProperties.forEach((conditionalChildProperties) => {
            const conditionalUsedPropertyNames = new Set(componentPropertyNames);
            conditionalChildProperties.properties.forEach((childProperty) => {
                this.validateProperty(childProperty, conditionalUsedPropertyNames, component);
            });
        });
    }
}
exports.PropertiesValidator = PropertiesValidator;
//# sourceMappingURL=properties-validator.js.map