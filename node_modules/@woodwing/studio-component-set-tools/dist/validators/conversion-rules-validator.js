"use strict";
/**
 * Validates if conversion rules reference to existing components and directives
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversionRulesValidator = void 0;
const validator_1 = require("./validator");
const models_1 = require("../models");
class ConversionRulesValidator extends validator_1.Validator {
    validate() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const srcComponentName of Object.keys(this.componentSet.conversionRules)) {
                if (!(srcComponentName in this.componentSet.components)) {
                    this.error(`Conversion rule references to non existing component "${srcComponentName}"`);
                    continue; // stop checking
                }
                for (const dstComponentName of Object.keys(this.componentSet.conversionRules[srcComponentName])) {
                    if (!(dstComponentName in this.componentSet.components)) {
                        this.error(`Conversion rule references to non existing component "${dstComponentName}"`);
                        continue; // stop checking
                    }
                    const rule = this.componentSet.conversionRules[srcComponentName][dstComponentName];
                    if (rule === 'auto') {
                        // nothing to check
                        continue; // stop checking
                    }
                    if (rule.type === 'simple') {
                        for (const dstDirectiveKey of Object.keys(rule.map)) {
                            if (!(dstDirectiveKey in this.componentSet.components[dstComponentName].directives)) {
                                this.error(`Conversion rule references to non existing directive "${dstDirectiveKey}"`);
                            }
                            const srcDirectiveKey = rule.map[dstDirectiveKey];
                            if (!(srcDirectiveKey in this.componentSet.components[srcComponentName].directives)) {
                                this.error(`Conversion rule references to non existing directive "${srcDirectiveKey}"`);
                            }
                        }
                        continue; // stop checking
                    }
                    if (rule.type === 'from-container') {
                        const srcDirectiveKey = rule.container;
                        if (!(srcDirectiveKey in this.componentSet.components[srcComponentName].directives)) {
                            this.error(`Conversion rule references to non existing directive "${srcDirectiveKey}"`);
                            continue; // stop checking
                        }
                        const srcDirectiveType = this.componentSet.components[srcComponentName].directives[srcDirectiveKey].type;
                        if (![models_1.DirectiveType.container, models_1.DirectiveType.slideshow].some((type) => type === srcDirectiveType)) {
                            this.error(`Conversion rule references to a directive "${srcDirectiveKey}" which must be "slideshow" or "container"`);
                        }
                        continue; // stop checking
                    }
                    if (rule.type === 'to-container') {
                        const dstDirectiveKey = rule.container;
                        if (!(dstDirectiveKey in this.componentSet.components[dstComponentName].directives)) {
                            this.error(`Conversion rule references to non existing directive "${dstDirectiveKey}"`);
                            continue; // stop checking
                        }
                        const dstDirectiveType = this.componentSet.components[dstComponentName].directives[dstDirectiveKey].type;
                        if (![models_1.DirectiveType.container, models_1.DirectiveType.slideshow].some((type) => type === dstDirectiveType)) {
                            this.error(`Conversion rule references to a directive "${dstDirectiveKey}" which must be "slideshow" or "container"`);
                        }
                        continue; // stop checking
                    }
                }
            }
        });
    }
}
exports.ConversionRulesValidator = ConversionRulesValidator;
//# sourceMappingURL=conversion-rules-validator.js.map