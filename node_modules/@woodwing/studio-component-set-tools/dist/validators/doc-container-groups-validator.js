"use strict";
/**
 * Validates groups of doc-container directives.
 * Theses groups are defined as part of the component definition and
 * are configurable per doc-container directive.
 *
 * These groups override the root level groups for the component picker popup inside a container.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocContainerGroupsValidator = void 0;
const validator_1 = require("./validator");
const groups_validator_1 = require("./groups-validator");
class DocContainerGroupsValidator extends validator_1.Validator {
    validate() {
        return __awaiter(this, void 0, void 0, function* () {
            // Find slides control properties and check for include and exclude
            for (const component of Object.values(this.componentSet.components)) {
                this.validateComponent(component);
            }
        });
    }
    /**
     * Validates groups of component.
     * These should have a matching doc-container directive.
     * They should also pass the group validator.
     *
     * @param errorReporter
     * @param component
     */
    validateComponent(component) {
        if (!component.directiveOptions) {
            return;
        }
        const groupsValidator = new groups_validator_1.GroupsValidator(this.error, this.componentSet);
        for (const [key, directiveOptions] of Object.entries(component.directiveOptions)) {
            // Rules only apply when it has a groups property defined
            if (!directiveOptions.groups) {
                continue;
            }
            if (!component.directives[key]) {
                this.error(`Component "${component.name}" has a group for invalid directive "${key}"`);
                continue;
            }
            if (component.directives[key].type !== 'container') {
                this.error(`Component "${component.name}" has a group for directive "${key}" with incompatible type "${component.directives[key].type}". Only type "container" is allowed.`);
                continue;
            }
            groupsValidator.validateGroupsList(directiveOptions.groups);
        }
    }
}
exports.DocContainerGroupsValidator = DocContainerGroupsValidator;
//# sourceMappingURL=doc-container-groups-validator.js.map