"use strict";
/**
 * Validates value of slides property
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlidesValidator = void 0;
const validator_1 = require("./validator");
class SlidesValidator extends validator_1.Validator {
    validate() {
        return __awaiter(this, void 0, void 0, function* () {
            // Find slides control properties and check for include and exclude
            for (const component of Object.values(this.componentSet.components)) {
                component.properties.forEach((property) => {
                    this.validateComponent(component, property);
                });
            }
        });
    }
    /**
     * Validates when slides property is found for component.
     * Checks if restrictChildren is set and validates the include and exclude properties
     * are valid for the slide component of doc-slideshow.
     */
    validateComponent(component, property) {
        if (property.control.type !== 'slides') {
            return;
        }
        if (!component.restrictChildren) {
            this.error(`Component "${component.name}" must have restrictChildren set to use the slides property`);
            return;
        }
        const slideComponentName = Object.keys(component.restrictChildren)[0];
        const slideComponent = this.componentSet.components[slideComponentName];
        if (property.control.include) {
            this.validateHasProperties(slideComponent, property, property.control.include);
        }
        if (property.control.exclude) {
            this.validateHasProperties(slideComponent, property, property.control.exclude);
        }
    }
    /**
     * Validate a list of property names are valid.
     */
    validateHasProperties(component, property, properties) {
        properties.forEach((propertyName) => {
            if (!this.hasProperty(component, propertyName)) {
                this.error(`Property "${property.name}" is referring to an invalid property "${propertyName}"` +
                    `not part of "${component.name}"`);
            }
        });
    }
    /**
     * Validate the component has the property.
     */
    hasProperty(component, propertyName) {
        for (let i = 0; i < component.properties.length; i++) {
            if (component.properties[i].name === propertyName) {
                return true;
            }
        }
        return false;
    }
}
exports.SlidesValidator = SlidesValidator;
//# sourceMappingURL=slides-validator.js.map