"use strict";
/**
 * Validates restrictChildren properties option
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestrictChildrenValidator = void 0;
const validator_1 = require("./validator");
const models_1 = require("../models");
const PROPERTY = 'restrictChildren';
const ADDITIONAL_PROPERTY = 'withContent';
class RestrictChildrenValidator extends validator_1.Validator {
    hasSlideshowDirective(component) {
        return Object.values(component.directives).some((directive) => directive.type === models_1.DirectiveType.slideshow);
    }
    validate() {
        return __awaiter(this, void 0, void 0, function* () {
            Object.values(this.componentSet.components).forEach((component) => {
                const isPresent = PROPERTY in component && component[PROPERTY];
                const hasSlideshow = this.hasSlideshowDirective(component);
                if (!isPresent) {
                    if (hasSlideshow) {
                        this.error(`Component property "${PROPERTY}" must be defined in component "${component.name}" because the ` +
                            `component contains a slideshow directive`);
                    }
                    return;
                }
                const propertyValue = component[PROPERTY] ||
                    // satisfy the compiler -> if PROPERTY exists then it is a non empty object otherwise it can't pass the schema
                    {};
                const propertyKeys = Object.keys(propertyValue);
                // slideshow component can have only one entry
                if (hasSlideshow && propertyKeys.length > 1) {
                    this.error(`Component property "${PROPERTY}" of component "${component.name}" must contain only one entry` +
                        ` because the component contains a slideshow directive`);
                }
                // check if all keys point to correct component
                propertyKeys.forEach((componentName) => {
                    if (componentName === component.name) {
                        this.error(`Component property "${PROPERTY}.${componentName}" of component "${component.name}" points to itself`);
                        return;
                    }
                    if (componentName in this.componentSet.components) {
                        const pointedParsedComponent = this.componentSet.components[componentName];
                        // check additional property
                        if (ADDITIONAL_PROPERTY in propertyValue[componentName]) {
                            const additionalPropertyValue = propertyValue[componentName][ADDITIONAL_PROPERTY] || '';
                            if (!(additionalPropertyValue in pointedParsedComponent.directives)) {
                                this.error(`Additional property "${ADDITIONAL_PROPERTY}" of property "${PROPERTY}.${componentName}" of component ` +
                                    `"${component.name}" points to non existing directive key "${additionalPropertyValue}" of component ` +
                                    `"${pointedParsedComponent.name}"`);
                            }
                        }
                    }
                    else {
                        this.error(`Component property "${PROPERTY}.${componentName}" of component "${component.name}" points to ` +
                            `non existing component`);
                    }
                });
            });
        });
    }
}
exports.RestrictChildrenValidator = RestrictChildrenValidator;
//# sourceMappingURL=restrict-children-validator.js.map